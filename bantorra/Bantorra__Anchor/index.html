<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bantorra__Anchor (bantorra.Bantorra__Anchor)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bantorra</a> &#x00BB; Bantorra__Anchor</nav><h1>Module <code>Bantorra__Anchor</code></h1><p>An anchor is a YAML file pinning the root of a library.</p><nav class="toc"><ul><li><a href="#format">Format</a></li><li><a href="#types">Types</a></li><li><a href="#anchor-i/o">Anchor I/O</a></li><li><a href="#accessors">Accessors</a></li></ul></nav></header><section><header><h2 id="format"><a href="#format" class="anchor"></a>Format</h2><p>It can be empty (equivalent to the YAML value <code>null</code>) or in one of the following formats:</p><pre>format: &quot;1.0.0&quot;</pre><pre>format: &quot;1.0.0&quot;
deps:
  - mount_point: [path, to, lib1]
    resolver: solver
    res_args:
      ...
  - mount_point: [path, to, lib2]
    resolver: solver
    res_args:
      ...</pre><p>If the <code>deps</code> field is missing or the entire anchor is equivalent to the YAML value <code>null</code> (e.g., empty), then the library has no dependencies. Each dependency is specifed by its mount point in the current library (<code>mount_point</code>), the name of the resolver to find the imported library(<code>resolver</code>), and the arguments to the resolver (<code>res_args</code>). During the resolution, the entire YAML subtree under the field <code>res_args</code> is sent to the resolver. See <span class="xref-unresolved" title="unresolved reference to &quot;Resolver.res_args&quot;"><code>Resolver</code>.res_args</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Resolver.make&quot;"><code>Resolver</code>.make</span>.</p><p>The order of entries in <code>dep</code> does not matter and the dispatching is based on longest prefix match. If no match can be found, then the unit path is local. The same library can be mounted at multiple points. However, to keep the resolution unambiguous, there cannot be two dependencies sharing the same mount point, and the mount point cannot be the empty list (the root). Here is an example demonstrating the longest prefix match:</p><pre>format: &quot;1.0.0&quot;
deps:
  - mount_point: [tcp]
    resolver: builtin
    res_args: tcp
  - mount_point: [tcp, http]
    resolver: builtin
    res_args: http</pre><p>The unit path <code>tcp.ftp</code> will be resolved to <code>ftp</code> in the <code>tcp</code> library, awaiting further resolution, while the unit path <code>tcp.http.connect</code> will be resolved to <code>connect</code> in the <code>http</code> library, not <code>http.connect</code> in the <code>tcp</code> library. Again, the order of dependencies does not matter.</p><p>If some library is mounted at <code>mylib.hello</code>, then the original unit associated with <code>mylib.hello</code> or any path with the prefix <code>mylib.hello</code> is no longer accessible. Moreover, <code>mylib.hello</code> cannot point to any unit after the mounting because there cannot be any unit associated with the empty path (the root), and <code>mylib.hello</code> means the empty path (the root) in the mounted library, which cannot point to anything.</p></header></section><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of anchors.</p></dd></dl><dl><dt class="spec type" id="type-unitpath"><a href="#type-unitpath" class="anchor"></a><code><span class="keyword">type</span> unitpath</code><code> = <span>string list</span></code></dt><dd><p>The type of unit paths.</p></dd></dl><dl><dt class="spec type" id="type-lib_ref"><a href="#type-lib_ref" class="anchor"></a><code><span class="keyword">type</span> lib_ref</code><code> = </code><code>{</code><table class="record"><tr id="type-lib_ref.resolver" class="anchored"><td class="def field"><a href="#type-lib_ref.resolver" class="anchor"></a><code>resolver : string;</code></td><td class="doc"><p>The name of the library resolver.</p></td></tr><tr id="type-lib_ref.res_args" class="anchored"><td class="def field"><a href="#type-lib_ref.res_args" class="anchor"></a><code>res_args : <a href="../Bantorra/Resolver/index.html#type-res_args">Bantorra.Resolver.res_args</a>;</code></td><td class="doc"><p>The arguments to the library resolver.</p></td></tr></table><code>}</code></dt><dd><p>The type of library references to be resolved.</p></dd></dl></section><section><header><h2 id="anchor-i/o"><a href="#anchor-i/o" class="anchor"></a>Anchor I/O</h2></header><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>read path</code> read the content of an anchor file.</p></dd></dl></section><section><header><h2 id="accessors"><a href="#accessors" class="anchor"></a>Accessors</h2></header><dl><dt class="spec value" id="val-iter_deps"><a href="#val-iter_deps" class="anchor"></a><code><span class="keyword">val</span> iter_deps : <span>(<a href="index.html#type-lib_ref">lib_ref</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter_lib_refs f a</code> runs <code>f</code> on each dependency listed in the anchor <code>a</code>.</p></dd></dl><dl><dt class="spec value" id="val-dispatch_path"><a href="#val-dispatch_path" class="anchor"></a><code><span class="keyword">val</span> dispatch_path : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-unitpath">unitpath</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-lib_ref">lib_ref</a> * <a href="index.html#type-unitpath">unitpath</a>)</span> option</span></code></dt><dd><p><code>dispatch_path a p</code> resolves the unit path <code>p</code> to <code>Some (ref, p')</code> if it points to a unit in another library referenced by <code>ref</code> and <code>p'</code>, or <code>None</code> if it is a local unit path. The dispatching is done by longest prefix match.</p></dd></dl></section></div></body></html>