<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BantorraResolvers__UserConfig (bantorra.BantorraResolvers__UserConfig)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bantorra</a> &#x00BB; BantorraResolvers__UserConfig</nav><h1>Module <code>BantorraResolvers__UserConfig</code></h1><h2 id="argument-format"><a href="#argument-format" class="anchor"></a>Argument Format</h2><p>The resolver takes a JSON argument in one of the following formats:</p><pre>{
  &quot;name&quot;: &quot;bantorra&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;
}</pre><pre>{
  &quot;name&quot;: &quot;bantorra&quot;,
  &quot;version&quot;: null
}</pre><pre>{ &quot;name&quot;: &quot;bantorra&quot; }</pre><p>A missing <code>version</code> is understood as the version <code>null</code>. Therefore, the last two specifications are identical. Versions are compared using structural equality. There is no smart comparison, version globbing, or ordering between versions. Each version is completely independent of each other; the version <code>null</code> only matches <code>null</code>, not any string version. Not even the string <code>&quot;null&quot;</code>.</p><p>However, one could have multiple versions of the same library registered in the user configuration file, as long as the versions <em>in use</em> all point to the same library on disk. (For example, one may have both versions <code>&quot;1.0&quot;</code> and <code>&quot;1&quot;</code> pointing to <code>/usr/lib/hello/1.0</code>, which means they can be used interchangeably.) Any attempt to load incompatible versions during the program execution would abort the library resolution.</p><nav class="toc"><ul><li><a href="#configeration-format">Configeration Format</a></li><li><a href="#builder">Builder</a></li><li><a href="#configuration-i/o">Configuration I/O</a></li></ul></nav></header><section><header><h2 id="configeration-format"><a href="#configeration-format" class="anchor"></a>Configeration Format</h2></header><aside><p>By default, the configuration is at <code>$XDG_CONFIG_HOME/${app_name}/${config}</code>. The exact path is given by <a href="../BantorraBasis/Xdg/index.html#val-get_config_home"><code>BantorraBasis.Xdg.get_config_home</code></a> concatenated with the argument <code>config</code> given to <a href="index.html#val-resolver"><code>resolver</code></a>.</p><p>Here is an example configuration file:</p><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;libraries&quot;: [
    {
      &quot;name&quot;: &quot;num&quot;,
      &quot;version&quot;: &quot;3&quot;,
      &quot;at&quot;: &quot;/usr/lib/something/num34&quot;
    },
    {
      &quot;name&quot;: &quot;tcp&quot;,
      &quot;version&quot;: &quot;2&quot;,
      &quot;at&quot;: &quot;/usr/lib/something/tcp21&quot;
    }
  ]
}</pre><p>Multiple versions of the same library name can be registered to enable dispatching on different versions. Multiple versions of the same library can be used as long as all these versions are pointing to the same location in the file system. (See below for a more detailed explanation.) Right now, no globbing or smart comparison is supported, but one may use the <code>versions</code> field instead of the <code>version</code> field, which takes a non-empty array of versions. An entry with a <code>versions</code> field is equivalent to multiple copies of that entry of listed <code>version</code>. That is, the following two configuration files are equivalent:</p><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;libraries&quot;: [
    {
      &quot;name&quot;: &quot;tcp&quot;,
      &quot;version&quot;: &quot;2&quot;,
      &quot;at&quot;: &quot;/usr/lib/something/tcp21&quot;
    },
    {
      &quot;name&quot;: &quot;tcp&quot;,
      &quot;version&quot;: &quot;2.1&quot;,
      &quot;at&quot;: &quot;/usr/lib/something/tcp21&quot;
    }
  ]
}</pre><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;libraries&quot;: [
    {
      &quot;name&quot;: &quot;tcp&quot;,
      &quot;versions&quot;: [&quot;2&quot;, &quot;2.1&quot;],
      &quot;at&quot;: &quot;/usr/lib/something/tcp21&quot;
    }
  ]
}</pre><p>The following is a more complicated example:</p><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;libraries&quot;: [
    {
      &quot;name&quot;: &quot;num&quot;,
      &quot;versions&quot;: [&quot;2&quot;, &quot;2.5&quot;],
      &quot;at&quot;: &quot;/usr/lib/something/num25&quot;
    },
    {
      &quot;name&quot;: &quot;num&quot;,
      &quot;version&quot;: &quot;3&quot;,
      &quot;at&quot;: &quot;/usr/lib/something/num34&quot;
    },
    {
      &quot;name&quot;: &quot;num&quot;,
      &quot;version&quot;: [&quot;3.4&quot;, null],
      &quot;at&quot;: &quot;/usr/lib/something/num34&quot;
    },
    {
      &quot;name&quot;: &quot;tcp&quot;,
      &quot;version&quot;: &quot;2&quot;,
      &quot;at&quot;: &quot;/usr/lib/something/tcp21&quot;
    },
    {
      &quot;name&quot;: &quot;tcp&quot;,
      &quot;version&quot;: &quot;2.1&quot;,
      &quot;at&quot;: &quot;/usr/lib/something/tcp21&quot;
    }
  ]
}</pre><p>Given the above configuration file, versions <code>&quot;2&quot;</code> and <code>&quot;2.5&quot;</code> of the library <code>num</code> are compatible because they point to the same library on disk. Versions <code>null</code> and <code>&quot;2&quot;</code> of the library <code>&quot;num&quot;</code> are not compatible because they point to different locations in the file system, and thus they cannot be used at the same time. Incompatible libraries cannot be loaded at the same time. Note that there is no version <code>null</code> registered for the library <code>tcp</code>, so one has to specify a string version (either <code>&quot;2&quot;</code> or <code>&quot;2.1&quot;</code>) for it, or the resolution would fail. The philosophy is that all entries must be explicitly listed.</p></aside></section><section><header><h2 id="builder"><a href="#builder" class="anchor"></a>Builder</h2></header><dl><dt class="spec value" id="val-resolver"><a href="#val-resolver" class="anchor"></a><code><span class="keyword">val</span> resolver : <span>app_name:string</span> <span>&#45;&gt;</span> <span>config:string</span> <span>&#45;&gt;</span> <a href="../Bantorra/Resolver/index.html#type-t">Bantorra.Resolver.t</a></code></dt><dd><p><code>resolver ~app_name ~config</code> constructs a resolver that reads the user configuration. The location of the user configuration is given by <a href="../BantorraBasis/Xdg/index.html#val-get_config_home"><code>BantorraBasis.Xdg.get_config_home</code></a> concatenated with <code>config</code>. All paths are normalized and turned into absolute paths with respect to the current working directory using <a href="../BantorraBasis/File/index.html#val-normalize_dir"><code>BantorraBasis.File.normalize_dir</code></a> .</p><p>If the configuration file does not exist, an empty mapping is used, which means the resolver would reject every request.</p><dl><dt>parameter app_name</dt><dd><p>The application name for generating a suitable directory to put the configuration file.</p></dd></dl><dl><dt>parameter config</dt><dd><p>The file name of the configuration file.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-clear_cached_configs"><a href="#val-clear_cached_configs" class="anchor"></a><code><span class="keyword">val</span> clear_cached_configs : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Configuration files are all cached to reduce I/O load, but perhaps you are bypassing this module to modify them. In that case, one should call this function to force rereading configuration files.</p></dd></dl></section><section><header><h2 id="configuration-i/o"><a href="#configuration-i/o" class="anchor"></a>Configuration I/O</h2></header><dl><dt class="spec type" id="type-versioned_library"><a href="#type-versioned_library" class="anchor"></a><code><span class="keyword">type</span> versioned_library</code><code> = </code><code>{</code><table class="record"><tr id="type-versioned_library.name" class="anchored"><td class="def field"><a href="#type-versioned_library.name" class="anchor"></a><code>name : string;</code></td></tr><tr id="type-versioned_library.version" class="anchored"><td class="def field"><a href="#type-versioned_library.version" class="anchor"></a><code>version : <span>string option</span>;</code></td></tr></table><code>}</code></dt><dd><p>The type of versioned library names. <code>None</code> corresponds to <code>null</code> and <code>Some ver</code> corresponds to explicit versions.</p></dd></dl><dl><dt class="spec type" id="type-filepath"><a href="#type-filepath" class="anchor"></a><code><span class="keyword">type</span> filepath</code><code> = string</code></dt><dt class="spec type" id="type-config"><a href="#type-config" class="anchor"></a><code><span class="keyword">type</span> config</code></dt><dd><p>The type of configurations as association lists.</p></dd></dl><dl><dt class="spec value" id="val-default_config"><a href="#val-default_config" class="anchor"></a><code><span class="keyword">val</span> default_config : <a href="index.html#type-config">config</a></code></dt><dd><p>Default configuration that is empty.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <span>app_name:string</span> <span>&#45;&gt;</span> <span>config:<a href="index.html#type-filepath">filepath</a></span> <span>&#45;&gt;</span> <a href="index.html#type-config">config</a></code></dt><dd><p>Try to read the configuration file. Note that the results are cached. See <a href="index.html#val-clear_cached_configs"><code>clear_cached_configs</code></a>. If the configuration file does not exist or is ill-formated, then the default configuration (the empty mapping) is returned. The cache will be updated accordingly.</p><dl><dt>parameter app_name</dt><dd><p>The application name for generating a suitable directory to put the configuration file.</p></dd></dl><dl><dt>parameter config</dt><dd><p>The file path of the configuration file.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lookup"><a href="#val-lookup" class="anchor"></a><code><span class="keyword">val</span> lookup : <span>name:string</span> <span>&#45;&gt;</span> <span>version:<span>string option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-config">config</a> <span>&#45;&gt;</span> <span><a href="index.html#type-filepath">filepath</a> option</span></code></dt><dt class="spec value" id="val-unsafe_write"><a href="#val-unsafe_write" class="anchor"></a><code><span class="keyword">val</span> unsafe_write : <span>app_name:string</span> <span>&#45;&gt;</span> <span>config:string</span> <span>&#45;&gt;</span> <a href="index.html#type-config">config</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write the configuration file. Do not use this function unless you know what you are doing. Due to some questionable design of the underlying OCaml YAML package <code>yaml</code>, strings such as <code>&quot;1.0&quot;</code> and <code>&quot;null&quot;</code> will not be serialized correctly. It is thus recommended to edit the configuration files directly before the package <code>yaml</code> is either fixed or replaced. See the <a href="https://github.com/avsm/ocaml-yaml/issues/39">issue on GitHub</a>.</p><p>The cache within this module will be updated upon successful writing. See <a href="index.html#val-clear_cached_configs"><code>clear_cached_configs</code></a>. However, the caveat in the package <code>yaml</code> means the written configuration file might be broken or different upon rereading.</p><dl><dt>parameter app_name</dt><dd><p>The application name for generating a suitable directory to put the configuration file.</p></dd></dl><dl><dt>parameter config</dt><dd><p>The file name of the configuration file.</p></dd></dl></dd></dl></section></div></body></html>