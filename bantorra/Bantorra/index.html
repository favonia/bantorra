<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bantorra (bantorra.Bantorra)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bantorra</a> &#x00BB; Bantorra</nav><h1>Module <code>Bantorra</code></h1><p>A Bantorra library is a virtual tree of units that can be accessed via unit paths from the root. The framework maps each unit path to the underlying file path via a flexible resolution process.</p><p>In the simplest case, there is a one-to-one correspondence between units and files under a specific directory: the unit path <code>a.b.c</code> corresponds to the file <code>a/b/c.suffix</code> where the extension <code>.suffix</code> is specified by the application. The root directory is marked by the existence of a special file with a name specified by the application. For example, the existence of the <code>dune</code> file means there is an OCaml library in the eyes of the <code>dune</code> building tool. These files are called <em>anchors</em> in the Bantorra framework, each marking the root of a collection of units that forms a <em>library</em>.</p><p>To access the units outside the current library, an anchor may <em>mount</em> a library in the tree, in a way similar to how partitions are mounted in POSIX-compliant systems. Here is a sample anchor file:</p><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;depends&quot;: [
    {
      &quot;mount_point&quot;: [&quot;lib&quot;, &quot;num&quot;],
      &quot;router&quot;: &quot;builtin&quot;,
      &quot;router_argument&quot;: &quot;number&quot;
    }
  ]
}</pre><p>The above anchor file mounts the library <code>number</code> at <code>lib.num</code> via the <code>builtin</code> router. With this, the unit path <code>lib.num.types</code>, for example, will be routed as the unit path <code>types</code> within the library <code>number</code>. The <code>builtin</code> router here is responsible for locating the root of this <code>number</code> library. The resolution is recursive because the depended library may depend on yet another library.</p><p>The implementation of the <code>builtin</code> router is specified by the application. For example, the application could use a fixed table router to implement the <code>builtin</code> router. A few basic routers are provided in <a href="../BantorraRouters/index.html">BantorraRouters</a>.</p><p>A Bantorra library manager holds the mapping from router names (such as <code>builtin</code>) to their implimentations (such as the fixed table) and is responsible for loading libraries. The manager is the entry point of the Bantorra framework---one should always start with a library manager and use it to load libraries. Here is an example:</p><pre><code class="ml">open Bantorra
open BantorraRouters

(* Create a fixed table router, ignoring errors. *)
let builtin = Result.get_ok @@ FixedTable.router ~dict:[&quot;number&quot;, &quot;../lib/number&quot;]

(** Get a library manager (ignoring error handling). *)
let manager = Result.get_ok @@ Manager.init ~anchor:&quot;lib&quot; ~routers:[&quot;builtin&quot;, builtin]

(** Load the library where the current directory belongs. *)
let lib_cwd, _ = Result.get_ok @@ Manager.load_library_from_cwd manager

(** Load a library using the [builtin] router. *)
let lib_number = Result.get_ok @@
  Manager.load_library_from_route manager
    ~starting_dir:(Sys.getcwd ())
    ~router:&quot;builtin&quot;
    ~router_argument:(`String &quot;number&quot;)

(** Directly load the library from its root without using any routing.
    (The manager will return the same library.) *)
let lib_number2 = Result.get_ok @@
  Manager.load_library_from_root manager &quot;../lib/number&quot;

(** Resolve a unit path and get its location in the file system. *)
let _local_lib, _local_unitpath, _filepath = Result.get_ok @@
  Manager.resolve manager lib_number [&quot;integer&quot;; &quot;relations&quot;] ~suffix:&quot;.source&quot;

(** Resolve the same unit path but with a different suffix. *)
let _local_lib, _local_unitpath, _filepath = Result.get_ok @@
  Manager.resolve manager lib_number [&quot;integer&quot;; &quot;relations&quot;] ~suffix:&quot;.compiled&quot;

(** Resolve another unit path and get its location in the file system.
    The result is the same as above because the library represented
    by [lib_number] is mounted at [lib.num]. *)
let local_lib2, local_path2, filepath2 = Result.get_ok @@
  Manager.resolve manager lib_cwd [&quot;lib&quot;; &quot;num&quot;; &quot;integer&quot;; &quot;relations&quot;] ~suffix:&quot;.source&quot;</code></pre><p>As shown above, the application can specify an arbitrary mapping from router names (such as <code>builtin</code>) to routers, possibly including new ones created for the application. There are a few basic routers in <a href="../BantorraResolvers/index.html">BantorraResolvers</a> and <a href="Router/index.html"><code>Router</code></a> defines what a router is.</p><nav class="toc"><ul><li><a href="#components">Components</a></li></ul></nav></header><section><header><h2 id="components"><a href="#components" class="anchor"></a>Components</h2></header><dl><dt class="spec module" id="module-Manager"><a href="#module-Manager" class="anchor"></a><code><span class="keyword">module</span> <a href="Manager/index.html">Manager</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Library managers.</p></dd></dl><dl><dt class="spec module" id="module-Router"><a href="#module-Router" class="anchor"></a><code><span class="keyword">module</span> <a href="Router/index.html">Router</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The type of routers.</p></dd></dl><dl><dt class="spec module" id="module-Errors"><a href="#module-Errors" class="anchor"></a><code><span class="keyword">module</span> <a href="Errors/index.html">Errors</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Utility functions to report errors.</p></dd></dl></section></div></body></html>