<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Anchor (bantorra.Bantorra.Anchor)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">bantorra</a> &#x00BB; <a href="../index.html">Bantorra</a> &#x00BB; Anchor</nav><h1>Module <code>Bantorra.Anchor</code></h1><p>Parser of anchor files.</p><nav class="toc"><ul><li><a href="#format">Format</a></li><li><a href="#types">Types</a></li><li><a href="#anchor-i/o">Anchor I/O</a></li><li><a href="#accessors">Accessors</a></li></ul></nav></header><aside></aside><aside><p>An anchor is a JSON file pinning the root of a library.</p></aside><section><header><h2 id="format"><a href="#format" class="anchor"></a>Format</h2><p>It can be in one of the following formats:</p><pre>{ &quot;format&quot;: &quot;1.0.0&quot; }</pre><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;deps&quot;: [
    {
      &quot;mount_point&quot;: [&quot;path&quot;, &quot;to&quot;, &quot;lib1&quot;],
      &quot;router&quot;: &quot;router1&quot;,
      &quot;router_argument&quot;: ...
    },
    {
      &quot;mount_point&quot;: [&quot;path&quot;, &quot;to&quot;, &quot;lib2&quot;],
      &quot;router&quot;: &quot;router2&quot;,
      &quot;router_argument&quot;: ...
    }
  ]
}</pre><p>If the <code>deps</code> field is missing, then the library has no dependencies. Each dependency is specified by its mount point in the current library (<code>mount_point</code>), the name of the router to find the imported library(<code>router</code>), and the argument to the router (<code>router_argument</code>). During the resolution, the entire JSON subtree under the field <code>router_argument</code> is passed to the router. See <a href="../Router/index.html#type-router_argument"><code>Router.router_argument</code></a> and <a href="../Router/index.html#val-make"><code>Router.make</code></a>.</p><p>The order of entries in <code>dep</code> does not matter and the dispatching is based on longest prefix match. If no match can be found, then the unit path is local. The same library can be mounted at multiple points. However, to keep the resolution unambiguous, there cannot be two dependencies sharing the same mount point, and the mount point cannot be the empty list (the root). Here is an example demonstrating the longest prefix match:</p><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;deps&quot;: [
    {
      &quot;mount_point&quot;: [&quot;tcp&quot;],
      &quot;router&quot;: &quot;builtin&quot;,
      &quot;router_argument&quot;: &quot;tcp&quot;
    },
    {
      &quot;mount_point&quot;: [&quot;tcp&quot;, &quot;bantorra&quot;],
      &quot;router&quot;: &quot;git&quot;,
      &quot;router_argument&quot;: {
        &quot;url&quot;: &quot;https://github.com/RedPRL/bantorra&quot;,
        &quot;branch&quot;: &quot;main&quot;
      }
    }
  ]
}</pre><p>The unit path <code>tcp.ftp</code> will be routed to the unit <code>ftp</code> within the <code>tcp</code> library, pending further resolution, while the unit path <code>tcp.bantorra.connect</code> will be routed to <code>connect</code> in the library corresponding to <code>https://github.com/RedPRL/bantorra</code>, not <code>http.connect</code> in the <code>tcp</code> library. Again, the order of dependencies does not matter because we are performing longest prefix match.</p><p>If some library is mounted at <code>mylib.hello</code>, then the original unit with the path <code>mylib.hello</code> or a path with the prefix <code>mylib.hello</code> is no longer accessible. Moreover, <code>mylib.hello</code> cannot point to any unit after the mounting because no unit can be associated with the empty path (the root), and <code>mylib.hello</code> means the empty path (the root) in the mounted library, which cannot refer to any unit.</p></header></section><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of anchors.</p></dd></dl><dl><dt class="spec type" id="type-unitpath"><a href="#type-unitpath" class="anchor"></a><code><span class="keyword">type</span> unitpath</code><code> = <span>string list</span></code></dt><dd><p>The type of unit paths.</p></dd></dl><dl><dt class="spec type" id="type-lib_ref"><a href="#type-lib_ref" class="anchor"></a><code><span class="keyword">type</span> lib_ref</code><code> = </code><code>{</code><table class="record"><tr id="type-lib_ref.router" class="anchored"><td class="def field"><a href="#type-lib_ref.router" class="anchor"></a><code>router : string;</code></td><td class="doc"><p>The name of the library router.</p></td></tr><tr id="type-lib_ref.router_argument" class="anchored"><td class="def field"><a href="#type-lib_ref.router_argument" class="anchor"></a><code>router_argument : <a href="../Router/index.html#type-router_argument">Router.router_argument</a>;</code></td><td class="doc"><p>The argument to the router.</p></td></tr></table><code>}</code></dt><dd><p>The type of library references to be routed.</p></dd></dl></section><section><header><h2 id="anchor-i/o"><a href="#anchor-i/o" class="anchor"></a>Anchor I/O</h2></header><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <span>`FormatError of string</span> <span><span>| `SystemError</span> of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>read path</code> read the content of an anchor file.</p></dd></dl></section><section><header><h2 id="accessors"><a href="#accessors" class="anchor"></a>Accessors</h2></header><dl><dt class="spec value" id="val-iter_routes"><a href="#val-iter_routes" class="anchor"></a><code><span class="keyword">val</span> iter_routes : <span>(<a href="index.html#type-lib_ref">lib_ref</a> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'e</span>)</span> Stdlib.result</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'e</span>)</span> Stdlib.result</span></code></dt><dt class="spec value" id="val-is_local"><a href="#val-is_local" class="anchor"></a><code><span class="keyword">val</span> is_local : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-unitpath">unitpath</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-dispatch_path"><a href="#val-dispatch_path" class="anchor"></a><code><span class="keyword">val</span> dispatch_path : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-unitpath">unitpath</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-lib_ref">lib_ref</a> * <a href="index.html#type-unitpath">unitpath</a>)</span> option</span></code></dt><dd><p><code>dispatch_path a p</code> routes the unit path <code>p</code> to <code>Some (ref, p')</code> if it points to a unit in another library referenced by <code>ref</code> and <code>p'</code>, or <code>None</code> if it is a local unit path. The dispatching is done by longest prefix match.</p></dd></dl></section></div></body></html>