<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Manager (bantorra.Bantorra__.Manager)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">bantorra</a> &#x00BB; <a href="../index.html">Bantorra__</a> &#x00BB; Manager</nav><h1>Module <code>Bantorra__.Manager</code></h1><nav class="toc"><ul><li><a href="#types">Types</a></li><li><a href="#initialization">Initialization</a></li><li><a href="#library-loading">Library Loading</a><ul><li><a href="#format-of-anchors">Format of Anchors</a></li></ul></li><li><a href="#composite-resolver">Composite Resolver</a></li></ul></nav></header><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of library managers.</p></dd></dl><dl><dt class="spec type" id="type-library"><a href="#type-library" class="anchor"></a><code><span class="keyword">type</span> library</code></dt><dd><p>The abstract type of libraries.</p></dd></dl><dl><dt class="spec type" id="type-unitpath"><a href="#type-unitpath" class="anchor"></a><code><span class="keyword">type</span> unitpath</code><code> = <span>string list</span></code></dt><dd><p>The type of unit paths.</p></dd></dl></section><section><header><h2 id="initialization"><a href="#initialization" class="anchor"></a>Initialization</h2></header><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>anchor:string</span> <span>&#45;&gt;</span> <span>routers:<span><span>(string * <a href="../../Bantorra/Router/index.html#type-t">Bantorra.Router.t</a>)</span> list</span></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <span>[&gt; <span>`InvalidRouter of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>init ~anchor ~routers</code> initiates a library manager for loading libraries.</p><dl><dt>parameter routers</dt><dd><p>An association list as a mapping from router names to available routers. See <code>Resolver</code>.</p></dd></dl><dl><dt>parameter anchor</dt><dd><p>The file name of the library anchors.</p></dd></dl></dd></dl></section><section><header><h2 id="library-loading"><a href="#library-loading" class="anchor"></a>Library Loading</h2></header><aside><p>A library is identified by a JSON file in its root directory, which is called &quot;anchor&quot;.</p></aside><section><header><h3 id="format-of-anchors"><a href="#format-of-anchors" class="anchor"></a>Format of Anchors</h3><p>An anchor can be in one of the following formats:</p><pre>{ &quot;format&quot;: &quot;1.0.0&quot; }</pre><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;deps&quot;: [
    {
      &quot;mount_point&quot;: [&quot;path&quot;, &quot;to&quot;, &quot;lib1&quot;],
      &quot;router&quot;: &quot;router1&quot;,
      &quot;router_argument&quot;: ...
    },
    {
      &quot;mount_point&quot;: [&quot;path&quot;, &quot;to&quot;, &quot;lib2&quot;],
      &quot;router&quot;: &quot;router2&quot;,
      &quot;router_argument&quot;: ...
    }
  ]
}</pre><p>If the <code>deps</code> field is missing, then the library has no dependencies. Each dependency is specified by its mount point in the current library (<code>mount_point</code>), the name of the router to find the imported library(<code>router</code>), and the argument to the router (<code>router_argument</code>). During the resolution, the entire JSON subtree under the field <code>router_argument</code> is passed to the router. See <a href="../Router/index.html#type-router_argument"><code>Router.router_argument</code></a> and <a href="../Router/index.html#val-make"><code>Router.make</code></a>.</p><p>The order of entries in <code>dep</code> does not matter and the dispatching is based on longest prefix match. If no match can be found, then the unit path is local. The same library can be mounted at multiple points. However, to keep the resolution unambiguous, there cannot be two dependencies sharing the same mount point, and the mount point cannot be the empty list (the root). Here is an example demonstrating the longest prefix match:</p><pre>{
  &quot;format&quot;: &quot;1.0.0&quot;,
  &quot;deps&quot;: [
    {
      &quot;mount_point&quot;: [&quot;world&quot;],
      &quot;router&quot;: &quot;builtin&quot;,
      &quot;router_argument&quot;: &quot;world&quot;
    },
    {
      &quot;mount_point&quot;: [&quot;world&quot;, &quot;bantorra&quot;],
      &quot;router&quot;: &quot;git&quot;,
      &quot;router_argument&quot;: {
        &quot;url&quot;: &quot;https://github.com/RedPRL/bantorra&quot;,
        &quot;branch&quot;: &quot;main&quot;
      }
    }
  ]
}</pre><p>The unit path <code>world.orntorra</code> will be routed to the unit <code>orntorra</code> within the <code>world</code> library, pending further resolution, while the unit path <code>world.bantorra.shisho</code> will be routed to <code>shisho</code> in the library corresponding to <code>https://github.com/RedPRL/bantorra</code>, not <code>bantorra.shisho</code> in the <code>world</code> library.</p><p>If some library is mounted at <code>world.towitorra</code>, then the original unit with the path <code>world.towitorra</code> or a path with the prefix <code>world.towitorra</code> is no longer accessible. Moreover, <code>world.towitorra</code> cannot point to any unit after the mounting because no unit can be associated with the empty path (the root), and <code>world.towitorra</code> means the empty path (the root) in the mounted library, which cannot refer to any unit.</p></header><dl><dt class="spec value" id="val-load_library_from_root"><a href="#val-load_library_from_root" class="anchor"></a><code><span class="keyword">val</span> load_library_from_root : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../BantorraBasis/File/index.html#type-filepath">BantorraBasis.File.filepath</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-library">library</a>, <span>[&gt; <span>`InvalidLibrary of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>load_library_from_root manager library_root</code> explicitly loads the library at the directory <code>library_root</code> from the file system. The loading fails if the anchor file cannot not be founded or is invalid.</p></dd></dl><dl><dt class="spec value" id="val-load_library_from_route"><a href="#val-load_library_from_route" class="anchor"></a><code><span class="keyword">val</span> load_library_from_route : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>router:string</span> <span>&#45;&gt;</span> <span>router_argument:<a href="../../BantorraBasis/Marshal/index.html#type-value">BantorraBasis.Marshal.value</a></span> <span>&#45;&gt;</span> <span>starting_dir:<a href="../../BantorraBasis/File/index.html#type-filepath">BantorraBasis.File.filepath</a></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-library">library</a>, <span>[&gt; <span>`InvalidLibrary of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>load_library_from_root ~router ~router_argument ~starting_dir</code> explicitly loads the library that the router <code>router</code> is returning with the argument <code>router_argument</code> starting at <code>starting_dir</code>. (Some routers would use the starting directory during the routing.) The loading fails if the routing fails or the anchor file could not be founded or is invalid.</p></dd></dl><dl><dt class="spec value" id="val-load_library_from_route_with_cwd"><a href="#val-load_library_from_route_with_cwd" class="anchor"></a><code><span class="keyword">val</span> load_library_from_route_with_cwd : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>router:string</span> <span>&#45;&gt;</span> <span>router_argument:<a href="../../BantorraBasis/Marshal/index.html#type-value">BantorraBasis.Marshal.value</a></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-library">library</a>, <span>[&gt; <span>`InvalidLibrary of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>load_library_from_root ~router ~router_argument</code> is the same as <code>val load_library_from_route</code><code>~router ~router_argument ~starting_dir</code> with <code>starting_dir</code> being the current working director.</p></dd></dl><dl><dt class="spec value" id="val-load_library_from_dir"><a href="#val-load_library_from_dir" class="anchor"></a><code><span class="keyword">val</span> load_library_from_dir : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../BantorraBasis/File/index.html#type-filepath">BantorraBasis.File.filepath</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-library">library</a> * <span><a href="index.html#type-unitpath">unitpath</a> option</span>, <span>[&gt; <span>`InvalidLibrary of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dt class="spec value" id="val-load_library_from_cwd"><a href="#val-load_library_from_cwd" class="anchor"></a><code><span class="keyword">val</span> load_library_from_cwd : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-library">library</a> * <span><a href="index.html#type-unitpath">unitpath</a> option</span>, <span>[&gt; <span>`InvalidLibrary of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dt class="spec value" id="val-load_library_from_unit"><a href="#val-load_library_from_unit" class="anchor"></a><code><span class="keyword">val</span> load_library_from_unit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>suffix:string</span> <span>&#45;&gt;</span> <a href="../../BantorraBasis/File/index.html#type-filepath">BantorraBasis.File.filepath</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-library">library</a> * <span><a href="index.html#type-unitpath">unitpath</a> option</span>, <span>[&gt; <span>`InvalidLibrary of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>locate_anchor_from_unit ~anchor ~suffix filepath</code> assumes the unit at <code>filepath</code> resides in some library and tries to find the root of the library by locating the file <code>anchor</code>. It returns the root of the found library and a unit path within the library that could potentially point to the input unit.</p><p>This is a helper function to prepare the arguments to <code>load_library</code>.</p></dd></dl></section></section><section><header><h2 id="composite-resolver"><a href="#composite-resolver" class="anchor"></a>Composite Resolver</h2><p>These functions will automatically load the dependencies.</p></header><dl><dt class="spec value" id="val-resolve"><a href="#val-resolve" class="anchor"></a><code><span class="keyword">val</span> resolve : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-library">library</a> <span>&#45;&gt;</span> <a href="index.html#type-unitpath">unitpath</a> <span>&#45;&gt;</span> <span>suffix:string</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-library">library</a> * <a href="index.html#type-unitpath">unitpath</a> * string, <span>[ <span>`InvalidLibrary of string</span> <span><span>| `UnitNotFound</span> of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>resolve manager lib unitpath ~suffix</code> resolves <code>unitpath</code> in the library <code>lib</code> and returns the <i>eventual</i> library where the unit belongs and the corresponding file path of the unit with the specified suffix. It is similar to <code>to_unitpath</code> but returns a file path instead of a unit path.</p><dl><dt>parameter suffix</dt><dd><p>The suffix shared by all the units in the file system.</p></dd></dl></dd></dl></section></div></body></html>