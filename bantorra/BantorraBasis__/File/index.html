<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>File (bantorra.BantorraBasis__.File)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">bantorra</a> &#x00BB; <a href="../index.html">BantorraBasis__</a> &#x00BB; File</nav><h1>Module <code>BantorraBasis__.File</code></h1><nav class="toc"><ul><li><a href="#pure-filename-calculation">Pure Filename Calculation</a></li><li><a href="#basic-i/o">Basic I/O</a></li><li><a href="#directories">Directories</a></li><li><a href="#which">Which</a></li><li><a href="#locating-files">Locating Files</a></li></ul></nav></header><section><header><h2 id="pure-filename-calculation"><a href="#pure-filename-calculation" class="anchor"></a>Pure Filename Calculation</h2></header><dl><dt class="spec value" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span class="keyword">val</span> (/) : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>p / q</code> concatenates paths <code>p</code> and <code>q</code>. The path <code>q</code> is assumed to be a relative path.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span>string list</span> <span>&#45;&gt;</span> string</code></dt><dd><p>The n-ary version of <a href="index.html#val-(/)"><code>(/)</code></a></p></dd></dl></section><section><header><h2 id="basic-i/o"><a href="#basic-i/o" class="anchor"></a>Basic I/O</h2></header><dl><dt class="spec value" id="val-writefile"><a href="#val-writefile" class="anchor"></a><code><span class="keyword">val</span> writefile : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>writefile path str</code> writes the string <code>str</code> the file at <code>path</code> (in binary mode). If there was already a file at <code>path</code>, it will be overwritten.</p></dd></dl><dl><dt class="spec value" id="val-writefile_noerr"><a href="#val-writefile_noerr" class="anchor"></a><code><span class="keyword">val</span> writefile_noerr : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>writefile_noerr path str</code> is similar to <code>writefile path str</code> except that all exceptions are caught and ignored.</p></dd></dl><dl><dt class="spec value" id="val-readfile"><a href="#val-readfile" class="anchor"></a><code><span class="keyword">val</span> readfile : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>readfile path</code> reads the content of string <code>str</code> the file at <code>path</code> (in binary mode). If there was already a file at <code>path</code>, it will be overwritten.</p></dd></dl></section><section><header><h2 id="directories"><a href="#directories" class="anchor"></a>Directories</h2></header><dl><dt class="spec value" id="val-ensure_dir"><a href="#val-ensure_dir" class="anchor"></a><code><span class="keyword">val</span> ensure_dir : string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ensure_dir dir</code> effectively implements <code>mkdir dir</code> in OCaml.</p></dd></dl><dl><dt class="spec value" id="val-protect_cwd"><a href="#val-protect_cwd" class="anchor"></a><code><span class="keyword">val</span> protect_cwd : <span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>protect_cwd f</code> runs <code>f cwd</code> where <code>cwd</code> is the current working directory, and restore the current working directory after the computation is done, even when an exception is raised.</p></dd></dl><dl><dt class="spec value" id="val-normalize_dir"><a href="#val-normalize_dir" class="anchor"></a><code><span class="keyword">val</span> normalize_dir : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>normalize_dir dir</code> uses <code>Sys.chdir</code> and <code>Sys.getcwd</code> to normalize a path. Symbolic links and special directories such as <code>.</code> and <code>..</code> will be resolved and the result will be an absolute path on many systems. The current working directory will be restored after the computation.</p></dd></dl></section><section><header><h2 id="which"><a href="#which" class="anchor"></a>Which</h2></header><dl><dt class="spec value" id="val-which"><a href="#val-which" class="anchor"></a><code><span class="keyword">val</span> which : string <span>&#45;&gt;</span> string</code></dt><dd><p>A hacky implementation inspired by the &quot;which&quot; tool on GNU/Linux systems.</p></dd></dl></section><section><header><h2 id="locating-files"><a href="#locating-files" class="anchor"></a>Locating Files</h2></header><dl><dt class="spec value" id="val-is_existing_and_regular"><a href="#val-is_existing_and_regular" class="anchor"></a><code><span class="keyword">val</span> is_existing_and_regular : string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_existing_and_regular path</code> tests whether there is a regular file (in particular, not a directory) at <code>path</code>. Symbolic links are followed before the testing.</p></dd></dl><dl><dt class="spec value" id="val-locate_anchor"><a href="#val-locate_anchor" class="anchor"></a><code><span class="keyword">val</span> locate_anchor : <span>anchor:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string * <span>string list</span></code></dt><dd><p><code>locate_anchor ~anchor dir</code> finds the closest regular file named <code>anchor</code> in <code>dir</code> or its ancestors in the file system tree. It returns the first directory that holds the file named <code>anchor</code> on the way from <code>dir</code> to the root directory, along with the relative path from the returned directory to <code>dir</code>. The exception <code>Not_found</code> is raised if such a file cannot be found.</p><p>For example, on a typical Linux system, suppose there is no file called <code>anchor.txt</code> under directiors <code>/usr/lib/gcc/</code> and <code>/usr/lib/</code>, but there is such a file under <code>/usr/</code>. <code>locate_anchor ~anchor:&quot;anchor.txt&quot; &quot;/usr/lib/gcc&quot;</code> will return <code>&quot;/usr&quot;, [&quot;lib&quot;; &quot;gcc&quot;]</code> and <code>locate_anchor ~anchor:&quot;anchor.txt&quot; &quot;/usr&quot;</code> will return <code>&quot;/usr&quot;, []</code>.</p></dd></dl><dl><dt class="spec value" id="val-locate_anchor_"><a href="#val-locate_anchor_" class="anchor"></a><code><span class="keyword">val</span> locate_anchor_ : <span>anchor:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>locate_anchor_ ~anchor dir</code> is the same as <code>locate_anchor ~anchor dir</code> except that the second component of the returned value is dropped. In other words, only the found directory is returned.</p></dd></dl></section></div></body></html>